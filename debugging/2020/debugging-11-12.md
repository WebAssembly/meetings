# Meeting notes for the November 12 video call of WebAssembly's debugging subgroup

- **Where**: zoom.us
- **When**: November 12, 11am-11:30 Pacific Standard Time (19:00 UTC, 20:00 CET)
- **Location**: *link on calendar invite*
- **Contact**:
    - Name: Derek Schuff
    - Email: dschuff@google.com
    
## Attendees
Yury Delendik, Luke Imhoff, Philip Pfaffe, Derek Schuff, Paolo Severini, Wouter Van Oortmerssen, Alon Zakai 

## Notes 
(Discussion summary)

We discussed how to handle wasm's memory64 extension in DWARF 
(recent context in LLVM changes https://reviews.llvm.org/D90503 and https://reviews.llvm.org/D91203).
Memory64 in wasm uses 64-bit data/memory indices, but 32-bit table indices and 32-bit values in the
binary for section offsets; and as in wasm32 there is no way for a program to explicitly refer to an 
instruction inside of a function. DWARF however does refer directly to instructions in the code section,
e.g. in `DW_AT_low_pc` attributes describing PC ranges, and some (but not all) other cases which encode
values using the `DW_FORM_addr` form. (And, the wasm64 ABI uses 64-bit function pointers to match data pointers).
In principle, DWARF attributes which refer to instructions in the binary could always use 32-bit values, while
attributes referring to functions or function pointers could match the size of the pointer used to compile
the program (64 when using memory64, 32 otherwise). Alternatively instruction-pointing attributes could always
be 64-bit, or could always match the size of data and function pointer.

This issue also becomes more interesting when considering the possibility of wasm modules having multiple
memories of different sizes. In that case, data pointer sizes would be different in different memories,
even in addition to the other possible mismatches. This is allowed by the wasm standard, and is potentially
useful, so we would probably not want to ban it in the standard. It probably can't currently be
generated by LLVM or linked by lld, but might potentially be in the future (e.g. LLVM currently allows
modules to have multiple address spaces of different sizes, which might transform straightforwardly
into a wasm module with multiple memories; and an extension to the linking convention might allow
lld to link such modules). However it's not clear what DWARF would look like for such modules, (e.g. 
whether or how DWARF could express it), nor how easy it would be to make producers and consumers
use it. Even for use cases that we currently imagine (e.g. tooling such as sanitizers), the memory
uses would be generated by tooling and the secondary memories would not contain user values that
dwarf would describe.

Currently the DW_AT_low_pc attributes are encoded with 32 bits even on wasm64 (the first alternative above).
Aside from matching the structure of the binary encoding most closely, it also has the advantage that
the proposed Binaryen pass for lowering memory64-using modules to MVP modules would not need to modify
the debug info. However there are likely other places in the current encoding
where we are using 32 bits where we should be using 64. More generally, there are likely to be
assumptions in current LLVM-ecosystem components (LLVM codegen, lldb, and lld) that instruction pointer
sizes would match the ABI function pointer size and possibly the data pointer size. Also the DWARF
address size matches the value size of the DWARF expression stack, so using an address size smaller
than the function pointer size could result in expression evaluation errors (e.g. overflows).
Fixing all of that would be an unknown but potentially large amount of work.
So it seems expedient for now to make all the dwarf address sizes match the C ABI pointer size.
In the future we may still face the multiple-memory problem and want to revisit some of these
tradeoffs.
