![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the January 13 video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: January 13, 17:00-18:00 UTC (9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
    - Compact import section: presentation and phase 3 poll ([repo](https://github.com/WebAssembly/compact-import-section/)) (Ben Visness, 30 min)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

To be filled in after the meeting.

### Attendees

Thomas Lively
Derek Schuff
Ben Visness
Nick Fitzgerald
Francis McCabe
Rezvan Mahdavi Hezaveh
Deepti Gandluri
Robin Freyler
Conrad Watt
Sam Clegg
Jeff Charles
Paolo Severini
Yuri Iozzelli
Manos Koukoutos
Michael Ficarra
Matthias Liedtke
Yury Delendik
Heejin Ahn
Dan Gohman
Ryan Hunt
Andreas Rossberg
Brendan Dahl
Alex Crichton
Zalim Bashorov
Bailey Hayes
Julien Pages 
Guy Bedford
Jakob Kummerow
Luke Wagner
Chris Woods
Emanuel Ziegler
Sergey Rubanov
Petr Penzin
Ricky Vetter
Steven Fontanella
Chris Woods

### Proposals and discussions

#### Compact import section: presentation and phase 3 poll ([repo](https://github.com/WebAssembly/compact-import-section/)) (Ben Visness, 30 min)

BV presenting slides (TODO link)

CW: I’m interested in in the outliers: do you have info on the biggest gains that you saw?

BV: I think calcworker was the biggest, so you’re seeing the biggest there. Calcworker’s import section shrunk by the biggest absolute. For total module, the best reduction was that 78KB from calcworker. There’s a link to this sheet in the slides.

spreadsheet: https://docs.google.com/spreadsheets/d/1QgA26STK3GRmV10uNqNLvWoHdWhA81sGSVwr0wF_540/edit?gid=0#gid=0

ZB: is it gzip?

BV: yes.

AR: the text format of the second one. It’s not what is speced, right? What we discussed in the PR?

BV: no? I thought I got it straight from the overview.

AR: maybe in the overview but not in the PR for the text format spec.

BV: the formal spec isn’t up to date yet, that’s part of the list in the presentation actually.

Yes, that’s whats in the overview and what’s implemented in wasm-tools. My understanding was that the formal spec was not a requirement for phase 3, so this would be sufficient

AR: yeah that’s fine; because we discussed the text format and I thought we had a different outcome.

BV: yeah not sure where we did that offhand. We can find the issue later.

Anyway I think there are basically  2 options: provide the type within the type group, or have it standalone. So depends on where you want your parens

CW: So you're proposing that we go to phase 3 with the extended format that deduplicates the types?

BV: yes.

FM: Did you run the experiment with just the second encoding and not the first one?

BV: I didn’t. I would imagine that the numbers in the sheet would be a very close estimate for what the sizes would be because you can easily get the additional savings from the second encoding with the delta, so this should show what you can get with externtypes alone. For me the module name redundancy is much more common form of redundancy and I think you almost always want it. It’s just so common to have a large group of imports at the top level, e.g. “env”. It’s possible that you have a lot with the same type, but you don’t find that many unique modules.

FM: I was hoping for just one extension to the binary format rather than 2; if you aggregate over both the module name and type it won’t be as effective as doing module only. But it might give you nearly the same compression.

TL In emscripten where every import comes from “env” but they all have different types, all you want to deduplicate is the module name. In wasm GC string imports, where they have the same module and same type, I think deduping both is worth it there. So i think they are useful for different use cases.

AR: more generally: what do we consider worthwhile? I was hoping we’d see a larger improvement, 1.27% doesn’t seem like a lot. Is it worth having extra complexity in the binary format, just for this? I’m thinking this maybe isn’t really worth it. Not a strong opinion, it’s not super complex but. It doesn’t affect performance, only size.

BV: except to the extent that size improves loading performance. To me the % wins for the import section are more significant than the ones for the overall module. Because of how wasm is organized, you get though the preamble and then do the functions in parallel, so  shrinking the preamble by a significant percent is still good. I haven’t done a measurement of parsing speedups, but if that’s something that gives us more confidence, I”d be willing to do taht.

NF (chat): do we have numbers on parsing speed ups?

ZB (chat): Isn't also may help with instantiation?

TL (chat): No, in this proposal there is no change to instantiation. We could consider optimizations in the specified instantiation algorithm separately.

RH: yeah it’s hard to have a general rule for how much complexity is worth what. It’s not earthshattering, but this is what I would exect for how we’d design the format if we were doing it from scratch over again. It’s very straightforward and I think it’s worth it. And we have to keep the uncompressed bytes around in memory, so every bit helps.

ML (chat): With module-splitting as a features toolchains are looking into the impact of imports vs. code section should also shift more towards the import section.

BV (chat): Re: instantiation, I think that is an issue to fix in the JS API (assuming we're talking about a large number of object lookups).

AR: We also see here that most cases are zero. Basically it helps some modules that import a lot of strings but in general it’s not a big effect. So the question is how relevant are these cases. I assume they are relevant, but in the overall picture…. Every engine has to implement this now. So what are the criteria for what’s worth it.

CW: with module splitting it becomes even more relevant to reduce the size of the import section.

TL: yeah we are experimenting more with module splitting, and the big expansion in imports that comes from that is starting to be a big problem. And you recall that we were also discussion type section duplication. The numbers in that discussion show a big expansion in import size.

AR: that mostly benefits from module name deduping rather than type deduping?

TL: yes. Type deduping remains useful for the strings use case.

RF: on performance, you might not only want to look at file size improvements. In wasmi, we found that import section validation was a noticeable cost, this might help with that.

AR: why?

RF: when you do lazy translation and function validation, the remaining parts that need validation were dominated by the type section. 30-40% or so.

AR: but you’re saying type section, that’s not the import section

RF: I mean both thats both together. So if the types need resolution, and string interning. They could benefit from a structure that deduplicates those strings already.

AR: not sure I understand why that would be the case. The import section mostly… for globals you validate the value type. For functions its just looking up the type index. I guess the main work is validating UTF-8, that would benefit from deduping the module name, that’s more decoding than validation but I can see that it benefits.

RF: don't have numbers currently, maybe I can get some.

BV: (status update slide)

AR: could we split [?]

TL: does anyone want to actually raise an objection to some part of the proposal?

AR: I’d want to change the text format, but that’s a detail we can do in phase 3. I would prefer only the module name deduping

DS: we can do a straw poll to see what folks generally prefer between compressing module names only vs both module names and types.

Informal poll results: 22 prefer both, 2 for module name only.

DS: to clarify, for those who prefer just modules, the preference is based on the tradeoff of complexity introduced vs the value that you get for it?

AR: yes, and also in terms of regularity. If you start going there, there are lots of things you could do, where do you stop?  The module by itself is a simple line.

FM: yes, if you were redesigning it, you’d probably do a lot of things, this is maybe something you wouldn’t do just as a single proposal. 

CWoods: Is it worth pausing and seeing how else we can reduce binary size so we don't have multiple similar proposals?

BV: IMO there aren’t a lot of other obvious sources of redundancy, imports are kind of unique in practice. We may not have known originally how imports would be used but it does seem to be the case that in some very common patterns we have pretty large redundancies. So there are things we could explore for overall shrinking, e.g. binary macros, string section etc. I look at 20-30% size reduction for the import section and th ink “that was pretty bad, it deserves a better encoding”

CW: i think the import section is probably self contained enough that it’s worth focused effort.

AR: Even within the import section you could imagine more. Such as factoring out common prefixes.

TL: i do think the narrow scope of this proposal is a feature, not a bug. As Ben said, it’s a single patch, it’s something I hope we can get out the door quickly and get the benefits. Slowing things down to increase the scope can be done independently.

AR: i actually do agree with that.

DS: based on the straw poll and the discussion I think we should do the phase 3 poll starting with both forms, and carry the discussion forward as an open item even if we go to phase 3.

SF: 17
F: 15
N: 0
A: 0
SA: 0 

JK (chat): if folks don't like space-efficient imported string constants, we can always do proper stringref instead :-)

ZB (chat): @Ben Visness do I understand correctly that you have a tool transforming JS String builtins proposal into compact imports? How we can apply it to our projects?

BV (chat):  Yes, I do - let me see what state that is in.

####  Restarting the threads subgroup meetings: Discussion (Thomas Lively, 10 min)

TL: we have a bunch of threads stuff happening, we discussed design issues and prototyping in October. Since then there’s been more progress and more folks working on it. So it would be good to make sure what we’re doing has consensus behind it. We already have the subgroup, so we should just schedule some meetings. I’m thinking every 4 weeks to start. Thinking of using the W3C  calendar, if you don’t know about that, it’s at https://www.w3.org/groups/cg/webassembly/calendar/ 
So I’ll put events there and you can import them into your preferred calendar, and anyone in the CG can join. If that sounds good, then please join, otherwise comments welcome.

RH: that arrangement and cadence sounds good.

TL: I’m curious how many folks think they’d join. (several reactions indicating interest). I’ll send an announcement to the CG list.

### Closure
