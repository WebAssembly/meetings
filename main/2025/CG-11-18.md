![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the November 18 video call of WebAssembly's Community Group

- **Where**: Virtual meeting
- **When**: November 18, 17:00-18:00 UTC (9am-10am PST, 18:00-19:00 CET)
- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/) or Google Calendar invitation*

### Registration

No registration is required for VC meetings. The meeting is open to CG members only.

## Agenda items

1. Opening
1. Proposals and discussions
   - Compact import section: presentation and phase 2 poll ([repo](https://github.com/WebAssembly/compact-import-section/)) (Ben Visness, 30 min)
1. Closure

## Agenda items for future meetings

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Ben Visness
- Paolo Severini
- Deepti Gandluri
- Yuri Iozzelli
- Colin Murphy
- Marcus Plutowski
- Luke Wagner
- Sam Clegg
- Julien Pages
- Derek Schuff
- Manos Koukoutos
- Ryan Hunt
- Emanuel Ziegler
- Colin Murphy
- Jakob Kummerow
- Rich Winterton
- Sean Jensen-Grey
- Andreas Rossberg
- Alex Crichton
- Robin Freyler
- Chris Woods
- Matthias Liedtke
- Zalim Bashorov
- Rezvan Mahdavi
- Nick
- Brendan Dahl
- Bailey Hayes
- Johnnie Birch
- Petr Penzin
- Shravan Narayan
- Steven Fontanella
- Deepti Gandluri

### Proposals and discussions

#### Compact import section: presentation and phase 2 poll ([repo](https://github.com/WebAssembly/compact-import-section/)) (Ben Visness, 30 min)

BV presenting [slides](https://docs.google.com/presentation/d/1JyCdPXf1g1eyNdmWLskBETHgcM0ybZ3TlKZ1re-iihY/edit?usp=sharing)

ZB (chat): Any idea about redundancy after compression?

BV: I didn’t get numbers for redundancy after compression… actually there are some numbers at the end, I can bring up the spreadsheet.

TL: Right now the JS spec for reading imports says that for every import, it reads the module object off the import object and the .. of the import object. Repeatedly doing that is a little wasteful. Have you considered updating the corresponding part of the JS API spec to also be more efficient?

BV: Yes, in the overview doc, in the link to “alternatives” its the first version that I specced and it was more of a pain to implement. The “read the imports” step is quite far away from the binary step. Irt requires updating the AST, instead of a flat list of imports, it stores a list of "import modules”, it propagates through all the spec machinery, the imports embedding function referenced by the JS spec. It’s the first thing I speced, when I first started implementing it, i was disappointed by how complex it was to change the internal representation of the imports, it requires propagating everything. Ti also plays poorly with things like the static … API, so you have to do something with compatibility. If you want to avoid the repeated lookups on the JS API, you could maybe add a cache in the “read the imports “step. Maybe that’s another way if we can contain the change to just the JS API spec rather than cascading the change everywhere. Or maybe we could optimize in the engine, we also discussed that internally, to optimize the gets if they are too slow. So we decided to change only the binary encoding and leave the internals the same.

JK (chat): Would be nice if "Read The Imports" had a clause to the effect of "if the module name is the same as the previous imports', then it might not be read again from the provided imports object". That would allow engines to avoid repeated property loads by caching them, and this optimization would then be quite straightforward (whereas today, while possible, it's rather cumbersome)

ZB: Have you considered something like a constant pool that could be used not just for the import section, but also in other places that use names? Similar to class files in Java. The name section also has lots of strings and is huge.

BV: We talked about some larger changes to the binary encoding that could reduce the size of names across the whole module. I think that this proposal would work fine with that. A constant pool on its  own wouldn’t really have all of the desired size savings. If we only had a const pool and kept the import section encoding the same, you’d pay the same cost as the single quote strategy since you’d have to in some way reference the name in the constant pool. I assume that would be at least 2 bytes so it would be the same overhead. It would be nice to use that in other places in the binary encoding, that could be nice. But given that structurally, imports do tend to have many with the same module name, i think it’s nice to reflect that with the encoding too.

SJG (chat): +1 on constant pool

AR: I second that. I want to point out that if the goal is to have a constant pool that works with the name section, then it would probably also have to be in a custom section. I don't think it makes sense to mix custom and non-custom sections. We could still add a constant pool for the name section.

AC: Have you considered compressing the type as well? You still have to have it for every name you’re importing, i would assume the type is the same for all the JS strings, hae you considered adding the type to the header where all the following names have the same type?

BV: I had not considered that.

RH: i think they are all required to have immutable externref as the type. We also talked about deduping the externtype, so you have a bunch of functions and they all follow one declaration. It’s hard to get the balance right of how much gain you get for changing the encoding.

BV: There is room in the proposed encoding for other compact encodings as well. If you choose a byte besides 0x7f, you can branch into another encoding. It would be possible to add new encodings for those special cases in the future.

JK (chat): 0x7E externtype list(name)

SC: Do you have a text format proposal for this too?

BV: Yes, there is a text format

ZB (chat): https://github.com/WebAssembly/compact-import-section/blob/main/proposals/compact-import-section/Overview.md#text-format 

BV: I would be happy to try adding a cache in the JS "read the imports" algo during stage 2. Since the lookups are observable, we’d have to be precise about which ones we say happen, and we’d have to make sure it’s web compatible.

JK: It would be a breaking change though. You might as well leave it imprecise.

TL: I still think we would want to be precise. So yes, this is a breaking change and we would have to check for web compatibility.

AR: Leaving it imprecise would also technically be a breaking change.

TL: For deferred loading of modules we are doing interesting things with proxies everywhere. But we are loading the same import object each time. Similarly, for the custom descriptors proposal there was an idea where you need to import 10k empty JS objects as the prototypes, so you can use a proxy to mint a new object every time, but that's just at the inner level and would not affect import modules.

5-way vote:

| SA | A | N | F | SF |
|---|---|---|---|---|
|0|0|2|13|11|

We have consensus for phase 2.

### Closure

