![WASI logo](https://raw.githubusercontent.com/WebAssembly/WASI/main/assets/WASI.png)

## Agenda: December 11 WASI video call

- **Location**: *link on W3C [calendar](https://www.w3.org/groups/cg/webassembly/calendar/)*
- **When**: December 11 2025, 17:00-18:00 UTC
- **Contact**:
  - Name: Yosh Wuyts and Bailey Hayes
  - Email: wasm@yosh.is and bailey@cosmonic.com

### Registration

The meeting is open to CG members only. You can [join the CG here](https://www.w3.org/community/webassembly/).

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Opening, welcome and roll call
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Proposals and discussions
    1. visibility: 'async' change in [CM issue #578](github.com/WebAssembly/component-model/pull/578) ([slides](https://docs.google.com/presentation/d/1SA_0zsh-pvBCc5j_O0IJyhvjWukALiBT-eAd_I6J3SQ)) (45min)

## Notes
### Attendees

- Bailey Hayes 
- Till Schneidereit
- Yosh Wuyts
- Joel Dice
- Dave Bakker
- Ryan Day
- Jeff Charles
- Kate Goldenring
- Michiel Van Kenhove
- Frank Schaffa
- Lukas Döllerer
- Sehyo Chang
- Roman Volosatovs

### visibility: 'async' change in CM issue #578

Luke: For the summary: look at component-model PR #578

Luke: We’re changing async from a hint in WIT to a runtime-enforced effect-type. The syntax remains unchanged, but instead of going in just the name without runtime semantics, it becomes an effect type on the function.

Luke: We want to enforce this async effect at runtime. If you do any things that block, haven’t returned a value yet, and you were called by a non-async function export, you then trap!

Luke: We made this change because we learned things while implementing component-model async in Jco. We found issues in the polyfill, and for a native browser implementation we found ourselves having to spin in a loop on the main loop, which is a big no-no. Two issues

Component exports couldn’t be called from callbacks (e.g. addEventListener)
Component exports couldn’t be called from constructors
Problem in JS guest bindings too (e.g. isomorphic JS)

Luke: Not just browsers and JS runtimes, but other event-based runtimes too, including plugin use cases.

Luke: what does blocking mean here?
waitable-set.wait
thread.suspend
synchronously calling an async function import
sync stream/future read,write, and cancel ops
sync subtask cancel
async calling

Luke: What about thread.yield? Not blocking. waitable-set.poll? also not blocking, never yields.

Luke: When do traps happen?

[export sync fn + sync lift] -> [import async fn + sync lower] traps
[export sync fn + async lift] -> [import async fn + sync lower] traps

Luke: this means that we now have to think about “async on the function” and “async on the lift and lower”

Luke: Is concurrency still colorless?

Luke: Async type does not force async source code. We can expect most exports to become async in the future. In the common case we do not export things to change. 

Luke: things are different for imports; mixing sync and async. 

Luke: When virtualizing things it becomes more complicated because we’re mixing sync and async across boundaries. “donut-wrapping” or “higher-order composition” is how we expect a lot of composition to happen. That is not a problem there because we control what blocking is and we can “lie” to ourselves about this, so it ends up working out.

Luke: one wrinkle with donut-wrapping because we can’t do recursive re-entrance, and that’s still a TODO. So it doesn’t yet work today, but we will in the future. This is the same feature which will enable callbacks in the future, which we know we want anyway.

Yosh: does that mean we can’t donut-wrap at all right now?

Luke: basically. There are some degenerate cases where we only import or only export that might work, but that’s rare. There is also a question about how toolchains would generate this in the first place, interesting bindgen question.

Luke: A good thing is that we no longer need to always create a fiber; now we can guarantee that in certain cases it won’t which is more efficient.

Luke: There is also the benefit that there is less to worry about for users.

Frank Schaffa: How would you verify that this works as intended? How do you verify it?

Luke: These are dynamic traps which are enforced by the component model runtime at runtime. Instead of waiting it traps instead.

Frank Schaffa: How do you provide the behavior you want for async? What’s my timeout and the like

Luke: Timeouts we leave it up to the compiler. The component model gives you cancellation primitives, and we also give you clocks, combine the two to get timeouts.

Joel Dice: the low level details of waitable sets and waitables will be abstracted by the bindings generators. In Go this would be a select block.

Luke: in JS abortcontroller and abortsignal

Frank: A donut can have multiple layers. If my top layer wants a shorter timeout than the inner layer, what happens?

Luke: There are no timeouts between components. We can however communicate cancellations between components, and we can communicate that.

Frank: I have thoughts about monoticity

Luke: please file any thoughts or issues on the component model repo if you have them
